# SSAFY 6기 공통 프로젝트 (DrawingDream) 회고록

7주동안의 공통 프로젝트가 끝났다!!!!! 와아아아

정말 밤낮없이 기획하고, 코딩하고, 수정하고 .... 

결과적으로 좋은 평가를 받아 최우수상을 수상해서 너무 행복하다 😊

TEAM DD  **인주비**, **장준범**, **제진명**, **박기범**, **손창현**, **이다예**

나를 포함한(~~ㅎㅎㅎㅎ~~) 6명에게 끝까지 달려오느라 수고했다는 말을 전하고 시작하고 싶다.

<br>
<br>

## 프로젝트 소개

![](https://images.velog.io/images/palacer/post/752ad008-5e10-4ff9-bad0-b3b581b6d113/image.png)

우리는 WebRTC 기술을 이용한 웹 기술 적용 프로젝트를 기획하자는 의견으로 뭉쳤다.

화상 통화 기능을 ‘교육’ 이라는 주제에 접목하고자 했고

이왕이면 사회적인 문제도 같이 해결할 수 있는

‘**의미 있는**’ 프로젝트를 진행하는 시간이 되었으면 했다.

<br>

코로나로 인해 비대면 교육이 오랜기간 지속되면서

학생들의 **사회성** 발달에 지장이 생기고 있다는 자료를 너무나 많이 접해봤었고,

실제 SSAFY 교육을 받으면서 비대면 교육과 관리를 위해서

웹 사이트, 화상 프로그램, 소통 프로그램 등을

동시에 사용하는 등  우리가 느꼈던 피교육자 입장에서의 **불편함**까지 해결하고 싶었다.

<br>

그 결과, 우리는 DrawingDream 이라는 ‘**비대면 통합 교육 플랫폼**’을 개발했다.

<br>

더 자세한 프로젝트 내용은
[DrawingDream](https://github.com/changhyuns/DrawingDream) 깃허브를 통해서 접할 수 있을 것이다  (지금은 private)

<br>


## 프로젝트 진행

우리는 프로젝트를 진행하면서 다양한 툴을 사용했다.

<br>

> 와이어프레임　　**Figma**

> 형상 관리　　　　**GitLab**

> 이슈 관리　　　　**Jira**

> 커뮤니케이션　　**Mattermost**

> 기록 및 문서　　　**Notion**

<br>

아이디어 기획부터 Figma를 통한 와이어프레임 제작, 발표 자료, API 명세 등

일정관리 및 기록이 필요하고 문서화가 필요한 작업들은 모두 _**Notion**_ 에서 진행했다.

<br>

대부분의 소통은 **Mattermost** 팀 채널에서 진행했는데,

정말 밤 낮 새벽 구분 없이 정말 채널을 불태웠다 💥💥💥

<br>

**GitLab**을 연동해서 push , merge request 등 이벤트를 실시간으로 채널에서 확인할 수 있었으며,

나중에 소개할 CI/CD pipeline 실행 결과도 바로바로 확인이 가능하도록 진행했다.

<br>

**Jira**는 처음 사용해봤는데 정말 좋은 경험이었다고 생각한다.

Agile - scrum 방식으로

Epic 설정으로 업무의 큰 틀을 잡은 후에

Story로 작은 업무 단위를 하나하나 작성했다.

Estimate는 프론트/백 팀별로 회의를 통해 스토리 포인트를 정하면서 진행했다.

<br>

<br> 

## 좋았던 점

이번 프로젝트를 통해 느낀점,  배운점 등을 해당 행동에 대한 결과와 함께 적어보고자 한다.

1. **기획 - 설계**
    
    우리는 노션에서 각자 생각한 아이디어를 쭈루룩 나열하고,
    
    어떤 방향으로 진행할지, 어떤 기능을 넣을지 등등 모든 것을 회의를 통해 정했다.
    
    기획 및 설계에만 2주라는 시간을 보냈고
    
    이미 정해져서 **문서화** 되어 있는 내용을 토대로 개발하다 보니까
    
    막상 개발을 시작하고 나서는 빠르게 진행되었던 것 같다.
    
    ~~(후반으로 가면서 수정에 수정을 거듭한건 어쩔 수 없지만)~~ 기획이 탄탄할수록 개발이 수월한 것 같다.
    
    ![](https://images.velog.io/images/palacer/post/7a2f8185-0e22-4667-8397-7de49725acc3/image.png)
    
2. **Git flow, Jira**
    
    우리는 소스 코드 관리를 위해서  Git branch 전략으로 **Git Flow**를 참고했다.
    
    hotfix를 제외한 나머지 4개의 브랜치(feature, develop, release, master)를 사용했고,
    
    미리 작성해둔 **커밋 컨벤션**에 따라 개발을 진행했다.
    
    ([https://udacity.github.io/git-styleguide/](https://udacity.github.io/git-styleguide/) 를 참고했다)
    
    또, **Jira**로 이슈 관리를 하면서 각 이슈에 대한 커밋은 Jira 티켓 번호를 연동하여 사용했고
    
    commit과 merge request가 생겨날수록, Jira 번 다운 차트는 우하향 곡선을 ~~나름~~ 이쁘게 그려나갔다.
    
    ![](https://images.velog.io/images/palacer/post/db8f9c48-f46b-4096-bd0f-51130fb82c61/image.png)
    
3. **CI/CD 구축**
    
    개인적으로 이번 프로젝트를 통해서 꼭! 내가 진행해보고 싶었던 파트였다.
    
    **젠킨스**와 **도커**를 이용했는데, 내가 구축한 플로우는 다음과 같다.
    
    ![](https://images.velog.io/images/palacer/post/3600e7a5-ec5c-4acf-90ed-e4e7083602fe/image.png)
    
    이번 프로젝트는** EC2 싱글 인스턴스** 제약 사항이 있었고, 다수의 유저가 존재하지 않았어서
    
    사실 **도커 허브**와 **로드 밸런싱**까지는 필요하지 않았지만
    
    제한된 환경에서 최대한 **_현실적인 인프라_** 를 구축해보고 싶었다.
    
    <br>
    
    여러 EC2 인스턴스를 사용하고, 다수의 학생들에게 원활한 서비스를 제공하기 위해서는
    
    각 인스턴스마다 이미지를 가져올 도커 허브가 필요했고,
    
    여러 개의 백엔드 서버단 앞에 로드 밸런서가 필요할거라고 생각했다.
    
    <br>
    
    Nginx conf 파일에서 upstream으로 백엔드 서버 2곳의 url을 설정하고 (다른 포트)
    
    proxy_pass를 통해 해당 upstream으로 요청이 가게끔 설정했다.
    
    분배 방식은 default가 라운드로빈 방식으로, 순서대로 돌아가며 요청을 분배하는 방법이지만
    
    온라인 수업을 진행하는 프로젝트의 특성상 서버와의 연결이 길어질 수 있다고 판단했고
    
    **least_conn** 설정을 통해 내부적으로 연결이 적은 서버로 요청을 분배하도록 해두었다.
    
    <br>
    
    말로만 들어본 로드밸런싱을 직접 구현하고서는
    
    실제로 4개의 계정 로그인시 백엔드 서버 2곳에 2명씩 할당되는 것을 보고 엄청 좋아했었다😎
    
    <br>
    
4. **보안**
    
    사실 부끄럽게도 지금껏 여러 사이트를 이용하면서 **HTTPS** 존재를 신경 써본 적이 없었다.
    
    요즘에는 보안을 신경쓰는건 기본 중 기본인데....
    
    ‘보안에 관해 기본적인것들을 신경써보자’ 해서 적용한 것이 HTTPS 프로토콜이었다.
    
    <br>
    
    **SSL 인증서**는 letsencrypt certbot을 이용해서 무료로 pem key를 발급받고,
    
    도메인을 통해 80 포트로 들어오는 http 요청은 모두 **443포트**로 리다이렉트 하게끔 했다.
    
    <br>
    
    더 나아가서, 데이터베이스를 구축할 때
    
    지금까지 당연하게 사용했던 auto increment PK를 사용하지 않고 **UUID** 형식의 PK를 사용했는데,
    
    <br>
    
    우리가 고려했던 상황 예시 아래와 같다.
    
    <br>
    
    >게시글 같은 경우 url에 표시된 게시글 번호(PK)로 
    >다음글, 이전글에 쉽게 접근할 수 있는 가능성이 있다. 
    
    <br>
    
    따라서 32자리의 랜덤 난수를 사용한 UUID 인공키를 사용하면 SQL Injection 같은 공격을 사전에 방지할 수 있다고 생각해서 적용했다.
    
    ~~(사실... 요즘 라이브러리 및 프레임워크에 기본적인 Injection 방지 기능이 있다는건 몰랐었다)~~
   
   <br>
    
5. **ORM - JPA**
    
    이번 프로젝트를 통해 처음으로 사용해본 **ORM**
    
    이전까지는 SQL문을 직접 하드코딩하고 변수값만 적용해서 데이터베이스에 접근했었고
    
    Mybatis를 사용해본게 전부인 나한테 **JPA**는 신세계였다.
    
    <br>
    
    ORM은 ‘_**객체는 객체대로, 관계형DB는 관계형DB대로**_’ 관리하는 것을 목표로 하는데
    
    개발자는 메서드를 이용하여 데이테베이스를 조작하고 내부적으로만 쿼리가 동작하기 때문에 비즈니스 로직에만 집중할 수 있다는 장점이 있다.
    
    <br>
    
    우리는 객체지향적인 코드를 통해 흔히들 말하는 ‘**유지보수**’가 용이하도록 개발했다~~고 생각한다.~~
    
    실제로 수정에 수정을 거듭한 프로젝트 막바지에는, 상황에 따라 코드 변경이 매우 수월했다.
    
    <br>
    
6. **공통코드**
    
    상황에 따라 많은 데이터를  그것도 **자주** 변경해야하는 일이 발생할 수 있다.
    
    <br>
    
    >예를들면, 회사에서 부서명을 지속적으로 변경한다던지, 특정 명칭을 수정하는 경우
    >해당 값을 사용하고 있는 모든 데이터를 변경해줘야 한다.
    
    <br>
    
    학교의 경우를 생각해보자.
    
    지금까지는 국어라고 부르던 과목을 '한국어'라고 변경한다던지
    
    1교시라고 하던 것을 'A교시'로 변경하고
    
    학생이라고 저장해놓은 데이터를 '교육생'으로 변경하는 경우에는
    
    얼마나 많은 데이터를 수정해야하는지 상상도 할 수 없다.
    
    <br>
    
    따라서 카테고리별로 정리해서,  여러 곳에서 사용되는 값이나 자주 변경이 될 수 있는 데이터를 고려하여  해당 데이터들을 **코드화**했다. (A01 B01 C06 등..)
    
    ![](https://images.velog.io/images/palacer/post/a9ee11e9-78b5-4d32-bea9-cb1cb99bc961/image.png)
    
    이미 저장해서 관리되고 있는 데이터들을 수정할 필요 없이 Code 테이블에서 해당 코드에 대한 값만 변경해주면, 
    
    코드를 참조하는 모든 데이터가 변경되기 때문에  공통코드 사용으로 **데이터의 유연성**을 확립할 수 있었다.
    
    <br>
    
7. **DTO 및 빌더 패턴 적용**
    
    지금까지는 회원정보는 UserDTO 딱 1개의 형식을 이용해서 데이터를 주고 받았었다.
    
    하지만 개발자 도구 - 네트워크 에서 호출되는 api를 살펴본 결과,
    
    response에 어떠한 데이터가 담겨서 들어오는지를 바로 확인할 수 있었고
    
    이것 또한 <U>보안적으로나, 성능적으로나</U> **옳지 않다**고 판단했다.
    
    <br>
    
    회원정보 중 a,b,c 만 필요한 페이지에서  회원정보를 얻어오는 api를 호출했을 때
    
    a,b,c,d,e,f,g 모든 정보가 넘어온다면 과연 그게 맞는 것일까 ?
    
    <br>
    
    a,b,c,d,e,f,g는 User Entity로 관리하는 **모든** 회원 정보인데
    
    클라이언트와 서버가 pure한 Entity를 가지고 데이터 통신을 하는 것을 지양하고
    
    각 경우마다 필요한 데이터들만 담는 **DTO** Class를 따로 두었다.
    
    <br>
    
    프로젝트 볼륨이 컸다보니까 RequestDTO와 ResponseDTO를 거의
    
    기계처럼 찍어내면서 그 수가 엄청나게 많아졌지만,
    
    공격자에게 추가적으로 정보를 제공하고
    
    항상 불필요한 데이터들이 포함되어서 전송되는 것 보다는 좋았다고 생각한다.
    
    <br>
    
    비슷한 맥락으로 우리는 **빌더 패턴**을 사용했다.
    
    기본적으로 객체를 생성할 때  생성자를 사용하는 경우에는
    
    값을 넣지 않을 파라미터에도 null 값이나, default 값을 넣어줘야 하고
    
    때로는 해당 파라미터를 포함하지 않은 여러 생성자를 만들어야 한다.
    
    ```java
    User user = User.builder()
    				.name("~~~")
    				.age(~~)
    				.build();
    ```
    
    위와 같은 형태의 **빌더**를 사용하여  동적으로 필요한 데이터만 설정할 수 있도록 했고
    
    불필요한 코드의 양을 줄이는 이점을 챙겼다.
    
    <br>
    
<br>

## 고난과 역경 ?  아쉬움 까지

개발을 하면서 문제가 생겼던 부분과 해결한 방법, 그 과정에서 아쉬웠던 점을 공유하고자 한다
<br>

1. **기획과 개발 시작의 경계선**
    
    우리는 6명이 2주동안 모두 기획에 참여했고, 동시에 개발을 시작했다.
    
    <br>
    
    초기 단계 백엔드 팀의 경우 gradle 프로젝트를 생성하고 나서 3명이 역할을 분담하기로 했는데
    
    >- 데이터베이스 구축 및 Entity Class 생성
    >- 기본적인 유저 관리 REST API 구축
    >- Spring Security 적용 - JWT 토큰 관리
    
    막상 시작하려고 보니까, 1번이 완료된 상태에서  2, 3번 작업 완료가 가능했다.
    
    <br>
    
    사실 아직까지도 어떻게 계획을 잡아야 시간적인 손실 없이
    
    일사천리로 개발이 가능한지는 고민중이다...😅
    
    <br>
    
    데이터베이스와 엔티티 작업을 먼저 다같이 진행했어야 하는지,
    
    유저 테이블에 관한것만 빠르게 작업했어야 하는지,
    
    기획 일정에서부터 누군가는 조금 먼저 빠져서 기본적인 구조를 잡았어야 했는지..
    
    **정답**이 따로 있을까..?   프로젝트 경험이 많아지다 보면 요령이 생기는걸까...?
    
    <br>
    
2. **불필요한 AccessToken 값 검증 코드의 반복**
    
    로그인과 회원가입, 아이디 중복 체크 까지 정확히 3개의 기능을 제외하고는
    
    모든 api를 호출할 때 request header에 토큰값을 넘겨줘서 로그인한 유저인지를
    
    controller단에서 항상 토큰 여부를 체크하고 401 unauthorized를 response로 반환하게끔 했었다.
    
    <br>
    
    사실 알고보니 백엔드 서버로 접근할 때
    
    미리 **Spring security**단에서 토큰을 확인하고 바로 401을 보내고 있었는데
    
    불필요한 검증 코드가 너무나 많은 곳에 작성되어 있었다..
    
    😎 **깨달음 + 1** 😎
    
    <br>
    
3. **빌더 패턴**
    
    위에서 **‘좋았던 점’**에서 빌더 패턴을 소개했는데, 왜 **아쉬움**까지 있을까 ?
    
    <br>
    
    나는 빌더 패턴을 **‘불변 객체’**랑 연관지어서 이해했는데,
    
    과연 회원 정보같이  <U>수정 기능</U>도 포함해야 하는 데이터의 **불변성**을 확립하는게 맞을까?
    <br>
    대부분의 경우에는 객체를 생성할 때 빌더패턴을 적용하는것이 좋다고들 하는데,
    
    빌더로 객체를 생성하는 것과, 데이터를 변경하는 것은 다른 부분인건지..
    
    아직까진 그 필요성에 대해 몸소 느끼고 있진 못해서 고민중인 부분이다.
    
    <br>
    
    특정 값을 변경해야 하는 경우 (비밀번호 수정이라던가..)
    
    비밀번호 필드값만 사용해서 빌드하면 수정이 되는 줄 알았던.. 시간도 있었다 ~~(ㅋㅋㅋㅋ)~~
    
    <br>
    
    새로운 객체가 생성된 것을 확인해보고 나서야 잘못했다는 것을 깨닫고는
    
    값을 변경할 수 있는 방법을 생각하다가
    
    따로 update(String password) 메서드를 사용하기로 했다.
    
    (update 같은 예약어 명칭보다는 change 같은 이름을 사용하는 것이 안전하다고 한다.)
    
    <br>
    
    하지만.. **setter**를 사용하는 것과 무엇이 다른지.. 이름만 다른거 같은데....
    
    불변 객체와 빌더 패턴,  세터 사용 지양 이유에 대해서  더 공부해야겠다.
    
    <br>
    
4. **CI/CD**
    
    마찬가지로 위에서 **‘좋았던 점’** 에 있는 내용이지만, **아쉬움**이 남는 것도 사실이다.
    
    <br>
    
    나는 젠킨스 freestyle project를 생성했고, shell script를 짜서
    
    깃 디렉토리를 이동하면서 프로젝트를 빌드 → 도커 이미지화 → 컨테이너 실행
    
    구조로 배포를 자동화했는데, 내가 구성한 형태가 맞는지는 아직 잘 모르겠다.
    
    <br>
    
    
   **"배포가 잘 되네!"**  에서 만족하고 싶지는 않고
    
    pipeline 으로 생성해서 각 단계별 진행 상황과 결과를 한눈에 보고 싶기도 하고,
    
    테스팅 서버 및 운영 서버를 따로 두면서  여러 EC2 인스턴스 구조에서
    
    각 서버를 운영해보고도 싶다. 추후 사이드 프로젝트로 진행해보는걸로 하자!
    
    <br>
    
5. **Web Socket & Load Balancing**
    
    로드 밸런싱을 구현하고 나서 최종 배포 상태를 확인하는 마지막 테스트에서
    
    엄청난 **버그**를 발견했다.
    
    <br>
    
    온라인 수업에 참여한 모든 사용자들이 채팅을 할 수 있도록 채팅창을 구현했는데
    
    A, B, C, D 참여자가 있으면 특정 채팅은 **A, C**만 볼 수 있고, 그 채팅을 제외한 나머지 채팅은
    
    **B, D**만 볼 수 있었다. 에러가 나는 상황도 아니었기 때문에 도대체 뭐가 문제지?..
    
    몇 시간을 내내 고민했었다.
    
    <br>
    
    결론적으로 말하자면, **로드 밸런싱**이 문제였다.
    
    채팅은 **서버**에서 컨트롤하고 있었고,
    
    온라인 화상 강의는 따로 **kurento 서버**를 두었는데
    
    <br>
    
    로드밸런싱으로 인해서 백엔드 서버 2곳으로 나뉘어진 사용자들끼리만
    
    서로 채팅을 확인할 수 있었던 것이다.. 눈물😥 
    
    <br>
    
    찾아보니까 웹 소켓같이 세션을 유지해야 하는 경우는
    
    로드 밸런서를 사용하지 못하는 **특수한 케이스**라고 한다.
    
    <br>
    
    로드 밸런서를 통하지 않고 직접 서버로 요청을 해야한다고 하는데
    
    이번 프로젝트의 경우  kurento 서버에 채팅 컨트롤이 가능하게끔 해야 하는지
    
    채팅에 관해서는 proxy_pass를 사용하지 않고
    
    클라이언트단에서 바로 백엔드 서버 1곳으로 요청을 보내야하는지 
    
    아직 답을 내지 못했다.
    
    <br>
    
    두 경우 모두  **내가 로드 밸런서를 둔 이유**와는 맞지 않는 것 같아서 속상하지만
    
    분명 이런 내 고민에도 누군가 지혜롭게 대처하도록 제공하는 정보들이 많을테니까
    
    검색을 통해 더 학습해보겠다.
    
    <br>
    <br>
    

## 마무리 하며

![](https://images.velog.io/images/palacer/post/255c529e-cacd-4765-9b22-aa21a872ddc6/image.png)

개발을 진행하는 동안  크롬 브라우저의 탭 목록이다.

이렇게 많은 탭이 띄워져 있던 크롬창이 4개나 됐는데 

정말 공식 문서나 유튜브 영상, 스택 오버플로우, 벨로그, 티스토리 등 **수백 개**의 자료들을

찾아보면서 진행했다....🤣 

<br>

누군가는 ~~정리좀 해라, 불필요한 창좀 닫아라!~~  할 수 있겠지만

자료들마다 내가 얻어갈 정보들이 다양하게 존재했기 때문에 프로젝트 마무리까지 

끝까지 탭을 유지하면서 진행했던 내 검색의 흔적이다 ~~(깨알 어필)~~

<br>

18년도 후반 컴퓨터공학과로 전과한 이후

가장 열심히 임했고, 가장 많은 것을 배웠으며, 누구보다 많이 깨달음을 얻었다고 확신할 수 있다.

물론 **아쉬운 점**도 많지만.

<br>

**회고록 작성**을 통해서 내가 느꼈던 점들과 배운 점들을 나열하다 보니까

**코드 리뷰**도 받아보고 싶고, **실무**에서 사용하는 구조, **aws 인프라** 등

너무 궁금한게 많아졌고  나도 언젠가 주니어, 시니어 개발자가 되어

지금의 나와 같은 고민을 하는 후배 개발자들에게 도움을 줄 수 있는  기술력과 지식을 갖추기 위해

**더 많은 경험**을 하러 출발하고자 한다.

<br>

회고록 도입부에도 추가해두었지만

이걸 작성하는 지금 이순간에  **SSAFY 6기 공통 프로젝트** 최종 결과가 나왔고

우리팀이 **최우수상**을 수상했다는 소식을 **다시** **한** **번** 자랑스럽게 말하고 마무리하겠다 ㅎㅎㅎㅎ

**Team DD** 짱
